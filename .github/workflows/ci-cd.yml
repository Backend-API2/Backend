name: CI/CD and Deploy to EC2

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

env:
  JAVA_VERSION: '21'
  WORKDIR: Backend

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Build with Maven (skip tests)
        run: mvn -B -DskipTests clean package

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-jar
          path: ${{ env.WORKDIR }}/target/Backend-*.jar

  test:
    runs-on: ubuntu-latest
    needs: build
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run tests with JaCoCo and coverage check
        run: |
          echo "üß™ Running tests with JaCoCo coverage..."
          mvn -B clean test jacoco:report

          echo "üìä Checking coverage threshold..."
          mvn -B jacoco:check

          echo "‚úÖ Coverage check passed!"

      - name: Upload coverage report
        if: ${{ hashFiles(format('{0}/target/site/jacoco/jacoco.xml', env.WORKDIR)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            ${{ env.WORKDIR }}/target/site/jacoco
            ${{ env.WORKDIR }}/target/jacoco.exec

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            try {
              // Read coverage report
              const coveragePath = path.join('${{ env.WORKDIR }}', 'target', 'site', 'jacoco', 'jacoco.csv');
              if (fs.existsSync(coveragePath)) {
                const coverageData = fs.readFileSync(coveragePath, 'utf8');
                const lines = coverageData.split('\n');
                const instructionLine = lines.find(line => line.includes('INSTRUCTION'));
                
                if (instructionLine) {
                  const parts = instructionLine.split(',');
                  const covered = parseInt(parts[3]);
                  const missed = parseInt(parts[4]);
                  const total = covered + missed;
                  const percentage = total > 0 ? ((covered / total) * 100).toFixed(2) : 0;
                  
                  const comment = `## üìä Coverage Report
                  
                  **Coverage: ${percentage}%** (${covered}/${total} instructions)
                  
                  ${percentage >= 75 ? '‚úÖ' : '‚ùå'} Coverage ${percentage >= 75 ? 'meets' : 'does not meet'} the minimum threshold of 75%
                  
                  <details>
                  <summary>View detailed coverage report</summary>
                  
                  \`\`\`
                  ${coverageData}
                  \`\`\`
                  </details>`;
                  
                  github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: comment
                  });
                }
              }
            } catch (error) {
              console.log('Could not generate coverage comment:', error.message);
            }

  sonar:
    runs-on: ubuntu-latest
    needs: test
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Generate coverage for Sonar
        run: mvn -B clean test jacoco:report

      - name: SonarCloud Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mvn -B -DskipTests \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
            org.sonarsource.scanner.maven:sonar-maven-plugin:5.2.0.4988:sonar

  deploy:
    needs: [build, test, sonar]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-jar
          path: ./artifacts

      - name: List available files
        run: |
          echo "Current directory:"
          pwd
          echo "Files in current directory:"
          ls -la
          echo "Files in scripts directory:"
          ls -la scripts/ || echo "Scripts directory not found"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"

      - name: Setup EC2 directories
        run: |
          echo "Creating app directory structure..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "mkdir -p /home/ec2-user/app/scripts"

      - name: Stop current application and free port 8080
        run: |
          echo "üõë Stopping current application if running..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            echo 'üîç Checking for processes using port 8080...'
            if [ -f /home/ec2-user/app/scripts/stop.sh ]; then
              echo 'Using stop script...'
              cd /home/ec2-user/app
              ./scripts/stop.sh || echo 'Stop script completed with warnings'
            fi
            PORT_PIDS=\$(lsof -ti:8080 2>/dev/null || echo '')
            if [ ! -z \"\$PORT_PIDS\" ]; then
              echo \"Found processes using port 8080: \$PORT_PIDS\"
              for PID in \$PORT_PIDS; do
                echo \"Killing process \$PID...\"
                kill -TERM \$PID 2>/dev/null || true
              done
              sleep 5
              for PID in \$PORT_PIDS; do
                if ps -p \$PID > /dev/null 2>&1; then
                  echo \"Force killing process \$PID...\"
                  kill -KILL \$PID 2>/dev/null || true
                fi
              done
            fi
          " || echo "‚ö†Ô∏è  First kill attempt completed with warnings"

      - name: Kill Java Backend processes and cleanup
        run: |
          echo "üîç Killing all Java Backend processes..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            echo 'Killing Java Backend processes...'
            pkill -f 'java.*Backend' 2>/dev/null || echo 'No Java Backend processes found'
            sleep 3
            echo 'Killing Java processes using port 8080...'
            for PID in \$(lsof -ti:8080 2>/dev/null || echo ''); do
              if ps -p \$PID -o comm= 2>/dev/null | grep -q java; then
                echo \"Killing Java process \$PID on port 8080...\"
                kill -KILL \$PID 2>/dev/null || true
              fi
            done
            if [ -f /home/ec2-user/app/app.pid ]; then
              PID=\$(cat /home/ec2-user/app/app.pid)
              echo \"Cleaning up PID file with PID \$PID...\"
              kill -KILL \$PID 2>/dev/null || true
              rm -f /home/ec2-user/app/app.pid
            fi
            echo 'Final cleanup of port 8080...'
            for PID in \$(lsof -ti:8080 2>/dev/null || echo ''); do
              echo \"Force killing remaining process \$PID on port 8080...\"
              kill -KILL \$PID 2>/dev/null || true
            done
            rm -f /home/ec2-user/app/app.log
          " || echo "‚ö†Ô∏è  Second kill attempt completed with warnings"

      - name: Verify port is free
        run: |
          echo "üîç Final verification..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            sleep 3
            if lsof -ti:8080 >/dev/null 2>&1; then
              echo \"‚ö†Ô∏è  Port 8080 still in use after all attempts\"
              echo \"Processes using port 8080:\"
              lsof -i:8080 || true
              echo \"All Java processes:\"
              ps aux | grep java || true
              exit 1
            else
              echo \"‚úÖ Port 8080 is now free\"
            fi
          "

      - name: Create and upload scripts
        run: |
          mkdir -p tmp-deploy-scripts

          cat > tmp-deploy-scripts/start.sh << 'EOF'
          #!/bin/bash
          APP_DIR="/home/ec2-user/app"
          JAR_FILE=$(find "$APP_DIR" -name "Backend-*.jar" -type f | head -1)
          PID_FILE="$APP_DIR/app.pid"
          LOG_FILE="$APP_DIR/app.log"

          if [ ! -f "$JAR_FILE" ]; then
              echo "‚ùå Error: No JAR file found in $APP_DIR"
              exit 1
          fi

          if [ -f "$PID_FILE" ]; then
              PID=$(cat "$PID_FILE")
              if ps -p "$PID" > /dev/null 2>&1; then
                  echo "‚ö†Ô∏è  Application is already running with PID $PID"
                  exit 1
              else
                  rm -f "$PID_FILE"
              fi
          fi

          echo "üöÄ Starting Backend application..."
          nohup java -jar -Dspring.profiles.active=prod "$JAR_FILE" > "$LOG_FILE" 2>&1 &
          APP_PID=$!
          echo "$APP_PID" > "$PID_FILE"

          sleep 5
          if ps -p "$APP_PID" > /dev/null 2>&1; then
              echo "‚úÖ Application started successfully with PID $APP_PID"
          else
              echo "‚ùå Failed to start application"
              rm -f "$PID_FILE"
              exit 1
          fi
          EOF

          cat > tmp-deploy-scripts/stop.sh << 'EOF'
          #!/bin/bash
          APP_DIR="/home/ec2-user/app"
          PID_FILE="$APP_DIR/app.pid"

          if [ ! -f "$PID_FILE" ]; then
              echo "‚ö†Ô∏è  No PID file found. Application might not be running."
              exit 0
          fi

          PID=$(cat "$PID_FILE")
          if ! ps -p "$PID" > /dev/null 2>&1; then
              echo "‚ö†Ô∏è  Process with PID $PID is not running. Removing stale PID file."
              rm -f "$PID_FILE"
              exit 0
          fi

          echo "üõë Stopping Backend application (PID: $PID)..."
          kill -TERM "$PID"

          for i in {1..30}; do
              if ! ps -p "$PID" > /dev/null 2>&1; then
                  echo "‚úÖ Application stopped gracefully"
                  rm -f "$PID_FILE"
                  exit 0
              fi
              echo "‚è≥ Waiting for graceful shutdown... ($i/30)"
              sleep 1
          done

          echo "‚ö†Ô∏è  Graceful shutdown failed. Force killing..."
          kill -KILL "$PID"
          sleep 2
          if ! ps -p "$PID" > /dev/null 2>&1; then
              echo "‚úÖ Application force stopped"
              rm -f "$PID_FILE"
          else
              echo "‚ùå Failed to stop application"
              exit 1
          fi
          EOF

          cat > tmp-deploy-scripts/restart.sh << 'EOF'
          #!/bin/bash
          echo "üîÑ Restarting Backend application..."
          cd /home/ec2-user/app
          echo "üõë Stopping existing processes..."
          ./scripts/stop.sh || echo "Stop script completed with warnings"
          echo "üßπ Additional cleanup..."
          pkill -f 'java.*Backend' 2>/dev/null || true
          sleep 2
          for PID in $(lsof -ti:8080 2>/dev/null || echo ''); do
            echo "Killing process $PID on port 8080..."
            kill -KILL "$PID" 2>/dev/null || true
          done
          rm -f app.pid app.log
          sleep 3
          echo "üöÄ Starting application..."
          ./scripts/start.sh
          EOF

          cat > tmp-deploy-scripts/status.sh << 'EOF'
          #!/bin/bash
          APP_DIR="/home/ec2-user/app"
          PID_FILE="$APP_DIR/app.pid"
          LOG_FILE="$APP_DIR/app.log"

          echo "üîç Backend Application Status"
          echo "=============================="

          if [ ! -f "$PID_FILE" ]; then
              echo "‚ùå Status: Not running (no PID file)"
              exit 1
          fi

          PID=$(cat "$PID_FILE")
          if ps -p "$PID" > /dev/null 2>&1; then
              echo "‚úÖ Status: Running (PID: $PID)"
              echo "üìä Process Info:"
              ps -p "$PID" -o pid,ppid,cmd,etime,pcpu,pmem

              if netstat -tlnp 2>/dev/null | grep -q ":$PID.*:8080"; then
                  echo "üåê Port 8080: Listening"
              else
                  echo "‚ö†Ô∏è  Port 8080: Not listening"
              fi

              echo "üè• Health Check:"
              if curl -f -s http://localhost:8080/actuator/health > /dev/null 2>&1; then
                  echo "‚úÖ Health: OK"
              else
                  echo "‚ùå Health: FAILED"
              fi

              echo ""
              echo "üìã Recent Logs (last 10 lines):"
              echo "--------------------------------"
              tail -10 "$LOG_FILE" 2>/dev/null || echo "No logs available"
          else
              echo "‚ùå Status: Not running (stale PID file)"
              rm -f "$PID_FILE"
              exit 1
          fi
          EOF

          # Upload scripts
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} tmp-deploy-scripts/*.sh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/scripts/

          # Make executable
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "chmod +x /home/ec2-user/app/scripts/*.sh"
          echo "‚úÖ Scripts uploaded and made executable"

      - name: Copy JAR to EC2
        run: |
          JAR_FILE=$(find ./artifacts -name "*.jar" -type f | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå No JAR file found in artifacts directory"
            ls -la ./artifacts/
            exit 1
          fi
          echo "üì¶ Found JAR file: $JAR_FILE"
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} "$JAR_FILE" ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/
          if [ $? -eq 0 ]; then
            echo "‚úÖ JAR file copied successfully"
          else
            echo "‚ùå Failed to copy JAR file"
            exit 1
          fi

      - name: Setup Docker and Docker Compose on EC2
        run: |
          echo "üê≥ Setting up Docker and Docker Compose..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo 'Installing Docker...'
              sudo yum update -y
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -a -G docker ec2-user
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo 'Installing Docker Compose...'
              sudo curl -L 'https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)' -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi
            
            # Start Docker service
            sudo systemctl start docker
            sudo systemctl enable docker
            
            echo 'Docker and Docker Compose setup completed'
          "

      - name: Upload monitoring configuration files
        run: |
          echo "üìã Uploading monitoring configuration files..."

          # Upload prometheus.yml
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} prometheus.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          # Upload alertmanager.yml
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} alertmanager.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          # Upload alert_rules.yml
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} alert_rules.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          # Upload docker-compose-monitoring.yml
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} docker-compose-monitoring.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          echo "‚úÖ Monitoring configuration files uploaded"

      - name: Start monitoring services
        run: |
          echo "üöÄ Starting monitoring services (Prometheus, Alertmanager, Grafana)..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            
            # Stop any existing monitoring services
            echo 'üõë Stopping existing monitoring services...'
            docker-compose -f docker-compose-monitoring.yml down --remove-orphans || true
            
            # Pull latest images
            echo 'üì• Pulling latest monitoring images...'
            docker-compose -f docker-compose-monitoring.yml pull
            
            # Start monitoring services in detached mode
            echo 'üöÄ Starting monitoring services...'
            docker-compose -f docker-compose-monitoring.yml up -d
            
            # Wait for services to be ready
            echo '‚è≥ Waiting for services to be ready...'
            sleep 30
            
            # Check if services are running
            echo 'üîç Checking service status...'
            docker-compose -f docker-compose-monitoring.yml ps
            
            # Verify Prometheus is accessible
            echo 'üîç Verifying Prometheus accessibility...'
            for i in {1..10}; do
              if curl -f -s http://localhost:9090/-/healthy > /dev/null 2>&1; then
                echo '‚úÖ Prometheus is healthy and accessible'
                break
              fi
              echo \"Attempt $i/10: Waiting for Prometheus...\"
              sleep 10
            done
            
            # Verify Alertmanager is accessible
            echo 'üîç Verifying Alertmanager accessibility...'
            for i in {1..10}; do
              if curl -f -s http://localhost:9093/-/healthy > /dev/null 2>&1; then
                echo '‚úÖ Alertmanager is healthy and accessible'
                break
              fi
              echo \"Attempt $i/10: Waiting for Alertmanager...\"
              sleep 10
            done
            
            # Verify Grafana is accessible
            echo 'üîç Verifying Grafana accessibility...'
            for i in {1..10}; do
              if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
                echo '‚úÖ Grafana is healthy and accessible'
                break
              fi
              echo \"Attempt $i/10: Waiting for Grafana...\"
              sleep 10
            done
            
            echo '‚úÖ Monitoring services started successfully'
          "

      - name: Show Alertmanager logs
        run: |
          echo "üìã Showing Alertmanager logs for verification..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            echo '=== Alertmanager Container Logs ==='
            docker-compose -f docker-compose-monitoring.yml logs --tail=50 alertmanager
            echo ''
            echo '=== Alertmanager Configuration Status ==='
            curl -s http://localhost:9093/api/v1/status | jq '.' || echo 'Alertmanager status check failed'
          "

      - name: Start application and health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT }}
          script: |
            cd /home/ec2-user/app
            chmod +x scripts/*.sh
            echo "üì¶ Current JAR files:"
            ls -la *.jar
            echo "üîÑ Restarting application..."
            ./scripts/restart.sh
            sleep 15
            echo "üîç Checking application status..."
            if [ -f app.pid ]; then
              PID=$(cat app.pid)
              if ps -p $PID > /dev/null 2>&1; then
                echo "‚úÖ Application is running with PID $PID"
              else
                echo "‚ùå Application failed to start"
                echo "üìã Recent logs:"
                tail -20 app.log
                exit 1
              fi
            else
              echo "‚ùå No PID file found"
              exit 1
            fi
            echo "üè• Performing health check..."
            for i in {1..5}; do
              echo "Attempt $i/5..."
              if curl -f -s http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo "‚úÖ Actuator health check passed!"
                break
              fi
              if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
                echo "‚úÖ Custom health check passed!"
                break
              fi
              echo "‚è≥ Waiting for application to start... (attempt $i/5)"
              sleep 10
            done
            echo "üîç Final verification..."
            echo "Custom health endpoint response:"
            curl -s http://localhost:8080/health || echo "Failed to reach /health"
            echo ""
            echo "Actuator health endpoint response:"
            curl -s http://localhost:8080/actuator/health || echo "Failed to reach /actuator/health"
            echo ""
            echo "‚úÖ Deployment completed successfully!"

      - name: Verify Prometheus can scrape backend
        run: |
          echo "üîç Verifying Prometheus can scrape backend metrics..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            # Wait a bit more for the backend to fully start
            sleep 10
            
            # Check if backend actuator endpoint is accessible
            echo 'üîç Checking backend actuator endpoint...'
            if curl -f -s http://localhost:8080/actuator/prometheus > /dev/null 2>&1; then
              echo '‚úÖ Backend actuator endpoint is accessible'
              
              # Check if Prometheus can reach the target
              echo 'üîç Checking Prometheus targets...'
              sleep 30  # Give Prometheus time to scrape
              
              # Get targets status from Prometheus
              TARGETS_RESPONSE=\$(curl -s http://localhost:9090/api/v1/targets)
              echo \"Prometheus targets response: \$TARGETS_RESPONSE\"
              
              # Check if our backend target is UP
              if echo \"\$TARGETS_RESPONSE\" | grep -q '\"health\":\"up\"'; then
                echo '‚úÖ Prometheus successfully scraping backend metrics'
              else
                echo '‚ö†Ô∏è  Backend target may not be UP in Prometheus'
                echo 'Checking individual target status...'
                curl -s 'http://localhost:9090/api/v1/targets' | jq '.data.activeTargets[] | select(.labels.job==\"spring-boot-backend\")' || echo 'Could not parse target status'
              fi
            else
              echo '‚ùå Backend actuator endpoint not accessible'
              echo 'Backend health check:'
              curl -s http://localhost:8080/actuator/health || echo 'Health endpoint failed'
            fi
          "

      - name: Optional monitoring services shutdown
        if: ${{ github.event.inputs.shutdown_monitoring == 'true' }}
        run: |
          echo "üõë Shutting down monitoring services (requested)..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            docker-compose -f docker-compose-monitoring.yml down
            echo '‚úÖ Monitoring services stopped'
          "
        continue-on-error: true
