name: CI/CD and Deploy to EC2

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

env:
  JAVA_VERSION: '21'
  WORKDIR: Backend

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Build with Maven (skip tests)
        run: mvn -B -DskipTests clean package -U

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-jar
          path: ${{ env.WORKDIR }}/target/Backend-*.jar

  test:
    runs-on: ubuntu-latest
    needs: build
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run tests with JaCoCo and coverage check
        run: |
          echo "üß™ Running tests with JaCoCo coverage..."
          mvn -B clean test jacoco:report

          echo "üìä Checking coverage threshold..."
          mvn -B jacoco:check

          echo "‚úÖ Coverage check passed!"

      - name: Upload coverage report
        if: ${{ hashFiles(format('{0}/target/site/jacoco/jacoco.xml', env.WORKDIR)) != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            ${{ env.WORKDIR }}/target/site/jacoco
            ${{ env.WORKDIR }}/target/jacoco.exec

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            try {
              // Read coverage report
              const coveragePath = path.join('${{ env.WORKDIR }}', 'target', 'site', 'jacoco', 'jacoco.csv');
              if (fs.existsSync(coveragePath)) {
                const coverageData = fs.readFileSync(coveragePath, 'utf8');
                const lines = coverageData.split('\n');
                const instructionLine = lines.find(line => line.includes('INSTRUCTION'));
                
                if (instructionLine) {
                  const parts = instructionLine.split(',');
                  const covered = parseInt(parts[3]);
                  const missed = parseInt(parts[4]);
                  const total = covered + missed;
                  const percentage = total > 0 ? ((covered / total) * 100).toFixed(2) : 0;
                  
                  const comment = `## üìä Coverage Report
                  
                  **Coverage: ${percentage}%** (${covered}/${total} instructions)
                  
                  ${percentage >= 75 ? '‚úÖ' : '‚ùå'} Coverage ${percentage >= 75 ? 'meets' : 'does not meet'} the minimum threshold of 75%
                  
                  <details>
                  <summary>View detailed coverage report</summary>
                  
                  \`\`\`
                  ${coverageData}
                  \`\`\`
                  </details>`;
                  
                  github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: comment
                  });
                }
              }
            } catch (error) {
              console.log('Could not generate coverage comment:', error.message);
            }

  sonar:
    runs-on: ubuntu-latest
    needs: test
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Temurin Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Generate coverage for Sonar
        run: mvn -B clean test jacoco:report

      - name: SonarCloud Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mvn -B -DskipTests \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
            org.sonarsource.scanner.maven:sonar-maven-plugin:5.2.0.4988:sonar

  deploy:
    needs: [build, test, sonar]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-jar
          path: ./artifacts

      - name: List available files
        run: |
          echo "Current directory:"
          pwd
          echo "Files in current directory:"
          ls -la
          echo "Files in scripts directory:"
          ls -la scripts/ || echo "Scripts directory not found"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"

      - name: Setup EC2 directories
        run: |
          echo "Creating app directory structure..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "mkdir -p /home/ec2-user/app/scripts"

      - name: Stop existing Docker services and clean Maven artifacts
        run: |
          echo "üõë Stopping existing Docker services and cleaning Maven artifacts..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            
            # Stop only staging Docker Compose services
            echo 'üõë Stopping staging Docker Compose services...'
            docker-compose -p app-staging down --remove-orphans || echo 'No staging services to stop'
            
            # Clean up Maven artifacts
            echo 'üßπ Cleaning up Maven artifacts...'
            if [ -d 'Backend/target' ]; then
              rm -rf Backend/target
              echo '‚úÖ Maven target directory cleaned'
            fi
            
            # Clean up .class files
            find . -name '*.class' -type f -delete 2>/dev/null || true
            find . -name '*.jar.original' -type f -delete 2>/dev/null || true
            
            # Clean up only staging orphaned containers
            echo 'üßπ Cleaning up staging orphaned containers...'
            docker container prune -f --filter "label=com.docker.compose.project=app-staging" || true
            
            # Clean up only staging networks (be more specific)
            echo 'üßπ Cleaning up unused networks (excluding production)...'
            docker network prune -f --filter "name=app-staging" || true
            
            echo '‚úÖ Docker and Maven cleanup completed'
          "

      - name: Verify Docker cleanup
        run: |
          echo "üîç Verifying Docker cleanup..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            
            # Check if staging containers are still running
            STAGING_CONTAINERS=\$(docker ps -q --filter "label=com.docker.compose.project=app-staging")
            if [ ! -z \"\$STAGING_CONTAINERS\" ]; then
              echo \"‚ö†Ô∏è  Some staging containers are still running:\"
              docker ps --filter "label=com.docker.compose.project=app-staging"
              echo \"Force stopping only staging containers...\"
              docker stop \$STAGING_CONTAINERS || true
            else
              echo \"‚úÖ No staging containers are running\"
            fi
            
            # Check if ports are free
            for PORT in 8080 9090 9093 3000; do
              if lsof -ti:\$PORT >/dev/null 2>&1; then
                echo \"‚ö†Ô∏è  Port \$PORT is still in use\"
                lsof -i:\$PORT || true
              else
                echo \"‚úÖ Port \$PORT is free\"
              fi
            done
          "

      - name: Upload Docker configuration files
        run: |
          echo "üìã Uploading Docker configuration files..."

          # Upload docker-compose.yml
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} docker-compose.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          # Upload Dockerfile (ahora dentro de Backend/)
          scp -r -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} Backend ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          # Upload monitoring configuration files
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} prometheus.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} alertmanager.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} alert_rules.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/

          echo "‚úÖ Docker configuration files uploaded"

      - name: Copy JAR to EC2
        run: |
          JAR_FILE=$(find ./artifacts -name "*.jar" -type f | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå No JAR file found in artifacts directory"
            ls -la ./artifacts/
            exit 1
          fi
          echo "üì¶ Found JAR file: $JAR_FILE"
          scp -o StrictHostKeyChecking=no -P ${{ secrets.EC2_PORT }} "$JAR_FILE" ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ec2-user/app/
          if [ $? -eq 0 ]; then
            echo "‚úÖ JAR file copied successfully"
          else
            echo "‚ùå Failed to copy JAR file"
            exit 1
          fi

      - name: Setup Docker and Docker Compose on EC2
        run: |
          echo "üê≥ Setting up Docker and Docker Compose..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo 'Installing Docker...'
              sudo yum update -y
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -a -G docker ec2-user
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo 'Installing Docker Compose...'
              sudo curl -L 'https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)' -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi
            
            # Start Docker service
            sudo systemctl start docker
            sudo systemctl enable docker
            
            echo 'Docker and Docker Compose setup completed'
          "

      - name: Build and deploy with Docker Compose
        run: |
          echo "üê≥ Building and deploying with Docker Compose..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            
            # Copy JAR file to build context
            echo 'üì¶ Copying JAR file to build context...'
            JAR_FILE=\$(find /home/ec2-user/app -name 'Backend-*.jar' -type f | head -1)
            if [ -z \"\$JAR_FILE\" ]; then
              echo '‚ùå No JAR file found in app directory'
              exit 1
            fi
            echo \"Found JAR file: \$JAR_FILE\"
            
            # Build Docker image for staging with complete cleanup
            echo 'üî® Building Docker image for staging with complete cleanup...'
            docker-compose -p app-staging build --no-cache --pull backend
            
            # Start staging services
            echo 'üöÄ Starting staging services with Docker Compose...'
            docker-compose -p app-staging up -d
            
            # Wait for services to be ready
            echo '‚è≥ Waiting for services to be ready...'
            sleep 30
            
            # Check service status
            echo 'üîç Checking service status...'
            docker-compose ps
            
            echo '‚úÖ Docker Compose deployment completed'
          "

      - name: Verify deployment and health checks
        run: |
          echo "üîç Verifying deployment and health checks..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            
            # Wait for services to be fully ready
            echo '‚è≥ Waiting for services to be fully ready...'
            sleep 30
            
            # Check Docker Compose service status
            echo 'üîç Checking Docker Compose service status...'
            docker-compose -p app-staging ps
            
            # Check backend health
            echo 'üè• Checking backend health...'
            for i in {1..10}; do
              if curl -f -s http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo '‚úÖ Backend health check passed'
                break
              fi
              echo \"Attempt $i/10: Waiting for backend...\"
              sleep 10
            done
            
            # Check Prometheus health
            echo 'üîç Checking Prometheus health...'
            for i in {1..5}; do
              if curl -f -s http://localhost:9090/-/healthy > /dev/null 2>&1; then
                echo '‚úÖ Prometheus health check passed'
                break
              fi
              echo \"Attempt $i/5: Waiting for Prometheus...\"
              sleep 10
            done
            
            # Check if Prometheus can scrape backend
            echo 'üîç Checking Prometheus targets...'
            sleep 30  # Give Prometheus time to scrape
            
            TARGETS_RESPONSE=\$(curl -s http://localhost:9090/api/v1/targets)
            if echo \"\$TARGETS_RESPONSE\" | grep -q '\"health\":\"up\"'; then
              echo '‚úÖ Prometheus successfully scraping backend metrics'
            else
              echo '‚ö†Ô∏è  Backend target may not be UP in Prometheus'
              echo 'Targets status:'
              curl -s 'http://localhost:9090/api/v1/targets' | jq '.data.activeTargets[] | select(.labels.job==\"spring-boot-backend\")' || echo 'Could not parse target status'
            fi
            
            # Check Grafana health
            echo 'üîç Checking Grafana health...'
            for i in {1..5}; do
              if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
                echo '‚úÖ Grafana health check passed'
                break
              fi
              echo \"Attempt $i/5: Waiting for Grafana...\"
              sleep 10
            done
            
            echo '‚úÖ All health checks completed'
          "

      - name: Optional services shutdown
        if: ${{ github.event.inputs.shutdown_services == 'true' }}
        run: |
          echo "üõë Shutting down staging services (requested)..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "
            cd /home/ec2-user/app
            docker-compose -p app-staging down
            echo '‚úÖ Staging services stopped'
          "
        continue-on-error: true
