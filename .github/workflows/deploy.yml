name: Build and Deploy Backend

on:
  push:
    branches:
      - master

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Build backend with Maven
        run: |
          cd Backend
          mvn clean package -DskipTests

          # Verificar que el JAR se gener√≥ correctamente
          echo "Verificando que el JAR se gener√≥:"
          ls -la target/
          if [ -f target/Backend-0.0.1-SNAPSHOT.jar ]; then
            echo "‚úì JAR generado correctamente"
            ls -la target/Backend-0.0.1-SNAPSHOT.jar
          else
            echo "‚úó ERROR: JAR no se gener√≥"
            echo "Contenido del directorio target:"
            ls -la target/
            exit 1
          fi

      - name: Test JAR execution
        run: |
          cd Backend
          echo "üß™ Testing JAR execution..."

          # Ejecutar el JAR en background con logs detallados
          echo "Iniciando aplicaci√≥n con perfil de producci√≥n..."
          java -jar target/Backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod > app.log 2>&1 &
          JAR_PID=$!

          # Funci√≥n para verificar health check con reintentos
          check_health() {
            local max_attempts=20
            local attempt=1
            local wait_time=8
            
            echo "Esperando a que la aplicaci√≥n se inicie completamente..."
            echo "Tiempo inicial de espera para que Spring Boot termine de arrancar..."
            sleep 15  # Espera inicial m√°s larga para que termine la inicializaci√≥n
            
            while [ $attempt -le $max_attempts ]; do
              echo "Intento $attempt/$max_attempts - Esperando ${wait_time}s..."
              sleep $wait_time
              
              # Verificar que el proceso sigue corriendo
              if ! ps -p $JAR_PID > /dev/null; then
                echo "‚ùå ERROR: La aplicaci√≥n se detuvo inesperadamente"
                echo "Logs de la aplicaci√≥n:"
                cat app.log
                exit 1
              fi
              
              # Verificar que el puerto est√© abierto primero
              echo "Verificando que el puerto 8080 est√© abierto..."
              if ! netstat -tuln | grep -q ":8080 "; then
                echo "‚ö†Ô∏è Puerto 8080 a√∫n no est√° abierto, esperando..."
                attempt=$((attempt + 1))
                continue
              fi
              
              echo "‚úÖ Puerto 8080 est√° abierto, probando health check..."
              
              # Probar health check
              if curl -f -s --connect-timeout 10 --max-time 15 http://localhost:8080/api/health/check > /dev/null 2>&1; then
                echo "‚úÖ Health check exitoso en /api/health/check"
                return 0
              elif curl -f -s --connect-timeout 10 --max-time 15 http://localhost:8080/api/health/ping > /dev/null 2>&1; then
                echo "‚úÖ Health check exitoso en /api/health/ping"
                return 0
              elif curl -f -s --connect-timeout 10 --max-time 15 http://localhost:8080/api/health/info > /dev/null 2>&1; then
                echo "‚úÖ Health check exitoso en /api/health/info"
                return 0
              else
                echo "‚ö†Ô∏è Health check fall√≥ en intento $attempt, reintentando..."
                
                # Mostrar logs parciales para debugging
                if [ $attempt -eq 10 ]; then
                  echo "Logs parciales de la aplicaci√≥n (mitad del proceso):"
                  tail -30 app.log
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå Health check fall√≥ despu√©s de $max_attempts intentos"
            echo "Logs completos de la aplicaci√≥n:"
            cat app.log
            return 1
          }

          # Ejecutar health check
          if check_health; then
            echo "‚úÖ Aplicaci√≥n iniciada y funcionando correctamente"
            
            # Probar conectividad b√°sica adicional
            echo "Probando conectividad b√°sica..."
            if curl -f -s --connect-timeout 5 --max-time 10 http://localhost:8080/ > /dev/null 2>&1; then
              echo "‚úÖ Backend responde correctamente en el puerto 8080"
            else
              echo "‚ö†Ô∏è Backend no responde en la ruta ra√≠z, pero health check funciona"
            fi
          else
            echo "‚ùå ERROR: La aplicaci√≥n no pudo inicializarse correctamente"
            exit 1
          fi

          # Terminar el proceso
          echo "Terminando proceso de prueba..."
          kill $JAR_PID
          wait $JAR_PID 2>/dev/null

      - name: Copy JAR to EC2
        uses: appleboy/scp-action@v0.1.6
        with:
          host: 18.191.118.13
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          source: 'Backend/target/Backend-0.0.1-SNAPSHOT.jar'
          target: '/home/ec2-user/'
          strip_components: 2
          timeout: 60s
          command_timeout: 60s

      - name: Verify JAR was copied
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: 18.191.118.13
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "Verificando que el JAR fue copiado correctamente:"
            echo "Contenido del directorio /home/ec2-user/:"
            ls -la /home/ec2-user/
            echo ""
            echo "Buscando archivos JAR:"
            find /home/ec2-user -name "*.jar" -type f
            echo ""

            # Verificar en la ubicaci√≥n esperada (con strip_components: 2)
            if [ -f /home/ec2-user/Backend-0.0.1-SNAPSHOT.jar ]; then
              echo "‚úì JAR file found successfully at expected location"
              ls -la /home/ec2-user/Backend-0.0.1-SNAPSHOT.jar
            # Verificar en la ubicaci√≥n alternativa (sin strip_components)
            elif [ -f /home/ec2-user/Backend/target/Backend-0.0.1-SNAPSHOT.jar ]; then
              echo "‚úì JAR file found at alternative location, moving to expected location"
              mv /home/ec2-user/Backend/target/Backend-0.0.1-SNAPSHOT.jar /home/ec2-user/Backend-0.0.1-SNAPSHOT.jar
              ls -la /home/ec2-user/Backend-0.0.1-SNAPSHOT.jar
            else
              echo "‚úó JAR file not found in any expected location"
              echo "ERROR: El archivo Backend-0.0.1-SNAPSHOT.jar no existe en el servidor"
              echo "Esto indica que el paso de copia (SCP) fall√≥"
              exit 1
            fi

      - name: Alternative copy with rsync (if SCP failed)
        if: failure()
        run: |
          echo "SCP fall√≥, intentando con rsync como alternativa..."
          # Instalar rsync si no est√° disponible
          sudo apt-get update && sudo apt-get install -y rsync

          # Crear la clave SSH temporal
          echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/ec2_key
          chmod 600 /tmp/ec2_key

          # Copiar con rsync (usando --remove-source-files para simular strip_components)
          rsync -avz --remove-source-files -e "ssh -i /tmp/ec2_key -o StrictHostKeyChecking=no" \
            Backend/target/Backend-0.0.1-SNAPSHOT.jar \
            ec2-user@18.191.118.13:/home/ec2-user/

          echo "Verificando que rsync funcion√≥:"
          ssh -i /tmp/ec2_key -o StrictHostKeyChecking=no ec2-user@18.191.118.13 \
            "ls -la /home/ec2-user/Backend-0.0.1-SNAPSHOT.jar"

          # Limpiar la clave temporal
          rm -f /tmp/ec2_key

      - name: Restart backend on EC2
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: 18.191.118.13
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ec2-user

            # Crear directorio deploy si no existe
            mkdir -p deploy

            # Parar procesos existentes (solo si existen)
            if pm2 list | grep -q "backend"; then
              echo "Parando proceso backend existente..."
              pm2 stop backend
              pm2 delete backend
            else
              echo "No hay proceso backend ejecut√°ndose, continuando..."
            fi

            # Mostrar contenido del directorio para debug
            echo "Contenido del directorio /home/ec2-user:"
            ls -la /home/ec2-user/

            # Verificar que el archivo JAR existe
            if [ ! -f Backend-0.0.1-SNAPSHOT.jar ]; then
              echo "ERROR: Backend-0.0.1-SNAPSHOT.jar no encontrado en /home/ec2-user/"
              echo "Buscando archivos JAR en el directorio:"
              find /home/ec2-user -name "*.jar" -type f
              exit 1
            fi

            # Limpiar archivos JAR antiguos (mantener solo el m√°s reciente)
            echo "Limpiando archivos JAR antiguos..."
            if [ -f backend.jar ]; then
              echo "Eliminando backend.jar anterior..."
              rm -f backend.jar
            fi

            # Mover el jar a la ubicaci√≥n final
            mv Backend-0.0.1-SNAPSHOT.jar backend.jar

            # Verificar que backend.jar exista
            if [ ! -f backend.jar ]; then
              echo "ERROR: backend.jar no encontrado despu√©s del move"
              exit 1
            fi

            echo "‚úÖ Archivo JAR actualizado correctamente"
            ls -la backend.jar

            # Iniciar con puerto 8080 (por defecto)
            pm2 start "java -jar backend.jar" --name backend

            # Verificar que el proceso se inici√≥ correctamente
            sleep 5
            echo "Estado de PM2 despu√©s del inicio:"
            pm2 status

            # Verificar que el proceso est√° realmente corriendo
            if pm2 list | grep -q "backend.*online"; then
              echo "‚úÖ Backend iniciado correctamente"
              echo "Puerto: 8080"
              echo "Estado: $(pm2 jlist | jq -r '.[] | select(.name=="backend") | .pm2_env.status')"
              
              # Verificar que el backend responde con health check robusto
              echo "üß™ Testing JAR execution..."
              
              # Funci√≥n para health check con reintentos en EC2
              check_ec2_health() {
                local max_attempts=20
                local attempt=1
                local wait_time=10
                
                echo "Esperando a que la aplicaci√≥n se inicie completamente en EC2..."
                echo "Tiempo inicial de espera para que Spring Boot termine de arrancar..."
                sleep 20  # Espera inicial m√°s larga para EC2
                
                while [ $attempt -le $max_attempts ]; do
                  echo "Intento $attempt/$max_attempts - Esperando ${wait_time}s..."
                  sleep $wait_time
                  
                  # Verificar que el proceso sigue corriendo en PM2
                  if ! pm2 list | grep -q "backend.*online"; then
                    echo "‚ùå ERROR: El proceso backend se detuvo inesperadamente"
                    echo "Estado de PM2:"
                    pm2 status
                    echo "Logs del proceso:"
                    pm2 logs backend --lines 50
                    exit 1
                  fi
                  
                  # Verificar que el puerto est√© abierto primero
                  echo "Verificando que el puerto 8080 est√© abierto..."
                  if ! netstat -tuln | grep -q ":8080 "; then
                    echo "‚ö†Ô∏è Puerto 8080 a√∫n no est√° abierto, esperando..."
                    attempt=$((attempt + 1))
                    continue
                  fi
                  
                  echo "‚úÖ Puerto 8080 est√° abierto, probando health check..."
                  
                  # Probar health check
                  if curl -f -s --connect-timeout 15 --max-time 20 http://localhost:8080/api/health/check > /dev/null 2>&1; then
                    echo "‚úÖ Health check exitoso en /api/health/check"
                    return 0
                  elif curl -f -s --connect-timeout 15 --max-time 20 http://localhost:8080/api/health/ping > /dev/null 2>&1; then
                    echo "‚úÖ Health check exitoso en /api/health/ping"
                    return 0
                  elif curl -f -s --connect-timeout 15 --max-time 20 http://localhost:8080/api/health/info > /dev/null 2>&1; then
                    echo "‚úÖ Health check exitoso en /api/health/info"
                    return 0
                  else
                    echo "‚ö†Ô∏è Health check fall√≥ en intento $attempt, reintentando..."
                    
                    # Mostrar logs parciales para debugging
                    if [ $attempt -eq 10 ]; then
                      echo "Logs parciales de la aplicaci√≥n (mitad del proceso):"
                      pm2 logs backend --lines 30
                    fi
                  fi
                  
                  attempt=$((attempt + 1))
                done
                
                echo "‚ùå Health check fall√≥ despu√©s de $max_attempts intentos"
                echo "Estado final de PM2:"
                pm2 status
                echo "Logs completos del proceso:"
                pm2 logs backend --lines 50
                return 1
              }

              # Ejecutar health check robusto
              if check_ec2_health; then
                echo "‚úÖ Aplicaci√≥n iniciada y funcionando correctamente en EC2"
                
                # Probar conectividad b√°sica adicional
                echo "Probando conectividad b√°sica..."
                if curl -f -s --connect-timeout 10 --max-time 15 http://localhost:8080/ > /dev/null 2>&1; then
                  echo "‚úÖ Backend responde correctamente en el puerto 8080"
                else
                  echo "‚ö†Ô∏è Backend no responde en la ruta ra√≠z, pero health check funciona"
                fi
              else
                echo "‚ùå ERROR: La aplicaci√≥n no pudo inicializarse correctamente en EC2"
                exit 1
              fi
            else
              echo "‚ùå ERROR: Backend no se inici√≥ correctamente"
              echo "Logs del proceso:"
              pm2 logs backend --lines 20
              exit 1
            fi
